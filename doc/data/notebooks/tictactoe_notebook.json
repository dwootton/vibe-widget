{
  "id": "tictactoe",
  "title": "Tic-Tac-Toe AI",
  "description": "Play against ML-powered AI",
  "widgets": {
    "tictactoe": {
      "url": "/widgets/interactive_tic_tac_toe_game_board_follo__ef3388891e__v1.js",
      "match": ["tic", "tac", "toe", "game board"]
    }
  },
  "dataFiles": [
    { "url": "/testdata/X_moves.csv", "varName": "x_moves_df" },
    { "url": "/testdata/O_moves.csv", "varName": "o_moves_df" }
  ],
  "cells": [
    {
      "type": "markdown",
      "content": "\n      <h2>Tic-Tac-Toe AI Demo</h2>\n      <p class=\"text-lg text-slate/70\">\n        Play against a machine learning AI! The model is trained on thousands of games\n        using scikit-learn's GradientBoostingClassifier.\n      </p>\n    "
    },
    {
      "type": "code",
      "content": "import vibe_widget as vw\nfrom sklearn.ensemble import AdaBoostClassifier, GradientBoostingClassifier, RandomForestClassifier\nfrom sklearn.model_selection import train_test_split\nimport numpy as np\nimport pandas as pd\n\n\n\nvw.config(model=\"google/gemini-3-flash-preview\", api_key=\"demo\")",
      "defaultCollapsed": true,
      "label": "Setup"
    },
    {
      "type": "code",
      "content": "# Check loaded training data\nprint(f\"Loaded X_moves: {len(x_moves_df)} moves\")\nprint(f\"Loaded O_moves: {len(o_moves_df)} moves\")\nprint(f\"Columns: {list(x_moves_df.columns[:10])}...\")",
      "defaultCollapsed": true,
      "label": "Data Check"
    },
    {
      "type": "markdown",
      "content": "\n      <h3>Training the AI</h3>\n      <p>We train two models - one for predicting rows and one for columns.</p>\n    ",
      "defaultCollapsed": true
    },
    {
      "type": "code",
      "content": "# Feature columns (board state encoding)\nfeature_cols = ['00-1', '00-2', '01-1', '01-2', '02-1', '02-2', \n                '10-1', '10-2', '11-1', '11-2', '12-1', '12-2', \n                '20-1', '20-2', '21-1', '21-2', '22-1', '22-2']\n\n\n# Prepare X training data (all winning games for X)\nX_features = x_moves_df[feature_cols]\nX_move_I = x_moves_df['move_I']\nX_move_J = x_moves_df['move_J']\n\n# Split for evaluation\nX_train_feat, X_test_feat, X_train_I, X_test_I, X_train_J, X_test_J = train_test_split(\n    X_features, X_move_I, X_move_J, test_size=0.15, random_state=42\n)\n\n\n# Train X player models with improved parameters\nprint(\"Training X row predictor (GradientBoosting with depth 5)...\")\nlr_I_X = GradientBoostingClassifier(\n    n_estimators=100, \n    max_depth=5, \n    learning_rate=0.1,\n    random_state=42\n)\nlr_I_X.fit(X_train_feat, X_train_I)\n\nprint(\"Training X column predictor (GradientBoosting with depth 5)...\")\nlr_J_X = GradientBoostingClassifier(\n    n_estimators=100, \n    max_depth=5, \n    learning_rate=0.1,\n    random_state=42\n)\nlr_J_X.fit(X_train_feat, X_train_J)\n\n# Evaluate X models\nX_I_acc = lr_I_X.score(X_test_feat, X_test_I)\nX_J_acc = lr_J_X.score(X_test_feat, X_test_J)\n\n# Prepare O training data (only winning games for O)\no_winning = o_moves_df[(o_moves_df['winner'] == 1) & (o_moves_df['move_I'] != -1)]\n\nO_features = o_winning[feature_cols]\nO_move_I = o_winning['move_I']\nO_move_J = o_winning['move_J']\n\n# Split for evaluation\nO_train_feat, O_test_feat, O_train_I, O_test_I, O_train_J, O_test_J = train_test_split(\n    O_features, O_move_I, O_move_J, test_size=0.15, random_state=42\n)\n\n# Train O player models with improved parameters\nprint(\"Training O row predictor (GradientBoosting with depth 5)...\")\nlr_I_O = GradientBoostingClassifier(\n    n_estimators=100, \n    max_depth=5, \n    learning_rate=0.1,\n    random_state=42\n)\nlr_I_O.fit(O_train_feat, O_train_I)\n\nprint(\"Training O column predictor (GradientBoosting with depth 5)...\")\nlr_J_O = GradientBoostingClassifier(\n    n_estimators=100, \n    max_depth=5, \n    learning_rate=0.1,\n    random_state=42\n)\nlr_J_O.fit(O_train_feat, O_train_J)\n\n# Evaluate O models\nO_I_acc = lr_I_O.score(O_test_feat, O_test_I)\nO_J_acc = lr_J_O.score(O_test_feat, O_test_J)\n",
      "defaultCollapsed": true,
      "label": "Train AI"
    },
    {
      "type": "code",
      "content": "# Helper functions for AI\n# Helper functions for board conversion\ndef board_to_features(board_list):\n    \"\"\"\n    Convert board state ['x','o','b',...] to feature vector for model.\n    board_list: 9-element list in order [00, 01, 02, 10, 11, 12, 20, 21, 22]\n    Returns: 18-element list with one-hot encoding\n    \"\"\"\n    features = []\n    for cell in board_list:\n        if cell == 'o':\n            features.extend([1.0, 0.0])\n        elif cell == 'x':\n            features.extend([0.0, 1.0])\n        else:  # 'b' for blank\n            features.extend([0.0, 0.0])\n    return features\n\ndef get_empty_positions(board_list):\n    \"\"\"Get list of empty (row, col) positions\"\"\"\n    empty = []\n    for idx, cell in enumerate(board_list):\n        if cell == 'b':\n            row = idx // 3\n            col = idx % 3\n            empty.append((row, col))\n    return empty\n\ndef check_winning_move(board_state, player):\n    \"\"\"Check if there's a winning move for the player\"\"\"\n    empty_positions = get_empty_positions(board_state)\n    for row, col in empty_positions:\n        idx = row * 3 + col\n        test_board = board_state.copy()\n        test_board[idx] = player\n        if check_winner(test_board) == player:\n            return (row, col)\n    return None\n\ndef check_winner(board):\n    \"\"\"Check if there's a winner on the board\"\"\"\n    # Check rows\n    for i in range(3):\n        if board[i*3] == board[i*3+1] == board[i*3+2] != 'b':\n            return board[i*3]\n    # Check columns\n    for i in range(3):\n        if board[i] == board[i+3] == board[i+6] != 'b':\n            return board[i]\n    # Check diagonals\n    if board[0] == board[4] == board[8] != 'b':\n        return board[0]\n    if board[2] == board[4] == board[6] != 'b':\n        return board[2]\n    return None\n\ndef predict_best_move(board_state, player='o'):\n    \"\"\"\n    Predict best move for given player using trained models.\n    board_state: 9-element list ['x','o','b',...] in order [00,01,02,10,11,12,20,21,22]\n    player: 'x' or 'o'\n    Returns: (row, col) tuple or None if no valid moves\n    \"\"\"\n    empty_positions = get_empty_positions(board_state)\n    if not empty_positions:\n        return None\n    \n    # First priority: Check if we can win\n    winning_move = check_winning_move(board_state, player)\n    if winning_move:\n        return winning_move\n    \n    # Second priority: Block opponent's winning move\n    opponent = 'x' if player == 'o' else 'o'\n    blocking_move = check_winning_move(board_state, opponent)\n    if blocking_move:\n        return blocking_move\n    \n    # Convert board to features\n    features = board_to_features(board_state)\n    X_input = pd.DataFrame([features], columns=feature_cols)\n    \n    # Get model predictions\n    if player == 'x':\n        I_probs = lr_I_X.predict_proba(X_input)\n        J_probs = lr_J_X.predict_proba(X_input)\n    else:  # 'o'\n        I_probs = lr_I_O.predict_proba(X_input)\n        J_probs = lr_J_O.predict_proba(X_input)\n    \n    # Compute joint probability matrix (outer product)\n    prob_matrix = np.dot(I_probs.T, J_probs)  # 3x3 matrix\n    \n    # Find best valid move\n    best_score = -1\n    best_move = None\n    \n    for row, col in empty_positions:\n        score = prob_matrix[row, col]\n        if score > best_score:\n            best_score = score\n            best_move = (row, col)\n    \n    return best_move",
      "defaultCollapsed": true,
      "label": "AI Functions"
    },
    {
      "type": "markdown",
      "content": "\n      <h3>The Game Board</h3>\n      <p>Click cells to play as <strong style=\"color: #007bff\">X (Blue)</strong>. The AI will respond as <strong style=\"color: #dc3545\">O (Red)</strong>!</p>\n    "
    },
    {
      "type": "code",
      "content": "# Create the game board widget with proper outputs\ngame_board = vw.create(\n    \"\"\"Interactive Tic-Tac-Toe game board\n    - Human plays X, AI plays O\n    - Click cells to make moves\n    - Outputs board_state, current_turn, game_over\n    - Inputs ai_move to receive AI responses\n    \"\"\",\n    outputs=vw.outputs(\n        board_state=\"9-element array of 'x', 'o', or 'b'\",\n        game_over=\"boolean\",\n        current_turn=\"'x' or 'o'\"\n    ),\n)\n\ngame_board",
      "label": "Game Board"
    },
    {
      "type": "code",
      "content": "# Create AI controller widget that computes moves\nimport time\n\n# This widget receives board state and computes AI moves\nai_controller = vw.create(\n    \"\"\"AI Move Controller\n    - Inputs board_state and current_turn from game board\n    - Computes optimal AI move using ML model\n    - Outputs ai_move to trigger board update\n    \"\"\",\n    outputs=vw.outputs(\n        ai_move=\"object {row: number, col: number}\"\n    ),\n)\n\ndef make_ai_move(change):\n    \"\"\"Called when board_state or current_turn changes\"\"\"\n    # Wait a bit for better UX\n    time.sleep(0.3)\n    \n    try:\n        board_state = game_board.outputs.board_state.value\n        current_turn = game_board.outputs.current_turn.value\n        game_over = game_board.outputs.game_over.value\n        \n        # Only make move if it's O's turn and game is not over\n        if current_turn != 'o' or game_over or not board_state:\n            return\n        \n        # Convert board_state to list if needed\n        if isinstance(board_state, str):\n            import ast\n            board_state = ast.literal_eval(board_state)\n        \n        # Ensure it's a list\n        board_list = list(board_state)\n        \n        # Validate board format (should be 9 elements)\n        if len(board_list) != 9:\n            print(f\"Invalid board state length: {len(board_list)}, expected 9\")\n            return\n        \n        # The board widget outputs in row-major order: [00,01,02,10,11,12,20,21,22]\n        # Our predict_best_move expects the same format\n        move = predict_best_move(board_list, player='o')\n        \n        if move:\n            print(f\"AI (O) plays at position ({move[0]}, {move[1]})\")\n            # Send move to AI controller which will notify game board\n            ai_controller.ai_move = {\"row\": int(move[0]), \"col\": int(move[1])}\n        else:\n            print(\"No valid move found\")\n            \n    except Exception as e:\n        print(f\"Error in AI move: {e}\")\n        import traceback\n        traceback.print_exc()\n\n# Observe changes to trigger AI moves\ngame_board.observe(make_ai_move, names=['current_turn'])\n\n# Link AI controller output to game board input\ngame_board_linked = vw.create(\n    \"\"\"Game board with AI integration\n    - Same as game_board but inputs ai_move from AI controller\n    \"\"\",\n    outputs=vw.outputs(\n        board_state=\"9-element array\",\n        game_over=\"boolean\",\n        current_turn=\"'x' or 'o'\"\n    ),\n    inputs=vw.inputs(\n        ai_move=ai_controller\n    ),\n)\n\nprint(\"AI controller linked to game board!\")\ngame_board",
      "label": "AI Controller"
    }
  ]
}
