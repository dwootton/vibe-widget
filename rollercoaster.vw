{
  "version": "1.0",
  "created_at": "2025-12-24T06:35:47.569689",
  "description": "k dhelp Create the 3D rollercoaster ride game from the perspective of the rider where a user can ride a roller coaster, speed up/down. The rollercoaster\n                    should be specified by the data values of a histogram of that column. A user can toggle which column to get the histogram of. \n                    ",
  "code": "import * as THREE from \"https://esm.sh/three@0.160.0\";\nimport * as d3 from \"https://esm.sh/d3@7\";\n\nconst THEME = {\n  midnightTeal: \"#01161e\",\n  deepWater: \"rgba(1, 34, 45, 0.8)\",\n  electricCyan: \"#00f0ff\",\n  seaSalt: \"#f0f9f9\",\n  sandGrey: \"#94a3b8\",\n  emerald: \"#10b981\",\n  sunlight: \"#fbbf24\",\n  border: \"rgba(100, 255, 218, 0.2)\",\n};\n\nconst ControlPanel = ({ html, column, setColumn, columns, speed, setSpeed }) => {\n  return html`\n    <div style=${{\n      position: 'absolute',\n      top: '20px',\n      left: '20px',\n      zIndex: 10,\n      background: THEME.deepWater,\n      padding: '16px',\n      borderRadius: '8px',\n      border: `1px solid ${THEME.border}`,\n      backdropFilter: 'blur(8px)',\n      color: THEME.seaSalt,\n      fontFamily: 'Montserrat, sans-serif',\n      display: 'flex',\n      flexDirection: 'column',\n      gap: '12px',\n      width: '220px'\n    }}>\n      <label style=${{ fontSize: '12px', fontWeight: 'bold', color: THEME.sandGrey }}>DATA TRACK</label>\n      <select \n        value=${column} \n        onChange=${(e) => setColumn(e.target.value)}\n        style=${{\n          background: THEME.midnightTeal,\n          color: THEME.electricCyan,\n          border: `1px solid ${THEME.electricCyan}`,\n          padding: '4px',\n          borderRadius: '4px',\n          outline: 'none'\n        }}\n      >\n        ${columns.map(col => html`<option value=${col}>${col}</option>`)}\n      </select>\n\n      <label style=${{ fontSize: '12px', fontWeight: 'bold', color: THEME.sandGrey, marginTop: '8px' }}>THRUST</label>\n      <input \n        type=\"range\" \n        min=\"0.1\" \n        max=\"2.0\" \n        step=\"0.1\" \n        value=${speed} \n        onInput=${(e) => setSpeed(parseFloat(e.target.value))}\n        style=${{ accentColor: THEME.electricCyan }}\n      />\n      <div style=${{ fontSize: '10px', textAlign: 'right', fontFamily: 'JetBrains Mono' }}>\n        ${(speed * 100).toFixed(0)}% VELOCITY\n      </div>\n    </div>\n  `;\n};\n\nexport default function RollerCoasterWidget({ model, html, React }) {\n  const containerRef = React.useRef(null);\n  const data = model.get(\"data\") || [];\n  const [column, setColumn] = React.useState(\"Age\");\n  const [speed, setSpeed] = React.useState(0.5);\n\n  const numericColumns = React.useMemo(() => {\n    if (data.length === 0) return [];\n    return Object.keys(data[0]).filter(k => typeof data[0][k] === 'number');\n  }, [data]);\n\n  React.useEffect(() => {\n    if (!containerRef.current || data.length === 0) return;\n\n    const width = containerRef.current.clientWidth;\n    const height = 500;\n\n    // 1. Scene Setup\n    const scene = new THREE.Scene();\n    scene.background = new THREE.Color(THEME.midnightTeal);\n    scene.fog = new THREE.FogExp2(THEME.midnightTeal, 0.015);\n\n    const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);\n    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n    renderer.setSize(width, height);\n    renderer.setPixelRatio(window.devicePixelRatio);\n    containerRef.current.appendChild(renderer.domElement);\n\n    // 2. Process Data for Track\n    const values = data.map(d => d[column]).filter(v => v != null && !isNaN(v));\n    const bins = d3.bin().thresholds(40)(values);\n    \n    // Create track points\n    const points = [];\n    bins.forEach((b, i) => {\n      const x = i * 20;\n      const y = (b.length || 0) * 2; // Height based on frequency\n      const z = Math.sin(i * 0.5) * 10; // Add some curves\n      points.push(new THREE.Vector3(x, y, z));\n    });\n\n    // Close the loop or extend for a long ride\n    const curve = new THREE.CatmullRomCurve3(points, true);\n    const tubeGeometry = new THREE.TubeGeometry(curve, 200, 0.5, 8, false);\n    const tubeMaterial = new THREE.MeshPhongMaterial({ \n      color: THEME.electricCyan, \n      emissive: THEME.electricCyan,\n      emissiveIntensity: 0.5,\n      wireframe: true \n    });\n    const track = new THREE.Mesh(tubeGeometry, tubeMaterial);\n    scene.add(track);\n\n    // Add \"Rails\" - two smaller tubes offset\n    [0.8, -0.8].forEach(offset => {\n        const railPoints = points.map(p => new THREE.Vector3(p.x, p.y - 0.5, p.z + offset));\n        const railCurve = new THREE.CatmullRomCurve3(railPoints, true);\n        const railGeo = new THREE.TubeGeometry(railCurve, 200, 0.1, 6, false);\n        const railMat = new THREE.MeshBasicMaterial({ color: THEME.emerald });\n        scene.add(new THREE.Mesh(railGeo, railMat));\n    });\n\n    // 3. Environment\n    const ambientLight = new THREE.AmbientLight(0x404040, 2);\n    scene.add(ambientLight);\n    const pointLight = new THREE.PointLight(THEME.sunlight, 100, 100);\n    scene.add(pointLight);\n\n    // Particles (Ocean Bubbles)\n    const partGeo = new THREE.BufferGeometry();\n    const partCount = 1000;\n    const posArray = new Float32Array(partCount * 3);\n    for(let i=0; i < partCount * 3; i++) {\n        posArray[i] = (Math.random() - 0.5) * 500;\n    }\n    partGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));\n    const partMat = new THREE.PointsMaterial({ size: 0.5, color: THEME.electricCyan, transparent: true, opacity: 0.5 });\n    const particles = new THREE.Points(partGeo, partMat);\n    scene.add(particles);\n\n    // 4. Animation Logic\n    let progress = 0;\n    let requestID;\n\n    const animate = () => {\n      requestID = requestAnimationFrame(animate);\n      \n      // Move rider along curve\n      progress += 0.0005 * speed;\n      if (progress > 1) progress = 0;\n\n      const pos = curve.getPointAt(progress);\n      const lookAt = curve.getPointAt((progress + 0.01) % 1);\n      \n      // Position camera slightly above the track\n      camera.position.set(pos.x, pos.y + 2, pos.z);\n      camera.lookAt(lookAt.x, lookAt.y + 1, lookAt.z);\n      \n      // Update light to follow rider\n      pointLight.position.copy(pos);\n      \n      renderer.render(scene, camera);\n    };\n\n    animate();\n\n    // Cleanup\n    return () => {\n      cancelAnimationFrame(requestID);\n      renderer.dispose();\n      tubeGeometry.dispose();\n      tubeMaterial.dispose();\n      if (containerRef.current) {\n        containerRef.current.removeChild(renderer.domElement);\n      }\n    };\n  }, [data, column, speed]);\n\n  return html`\n    <div style=${{ \n      position: 'relative', \n      width: '100%', \n      height: '500px', \n      background: THEME.midnightTeal,\n      overflow: 'hidden',\n      borderRadius: '12px',\n      boxShadow: '0 10px 30px rgba(0,0,0,0.5)'\n    }}>\n      <${ControlPanel} \n        html=${html} \n        column=${column} \n        setColumn=${setColumn} \n        columns=${numericColumns} \n        speed=${speed} \n        setSpeed=${setSpeed} \n      />\n      \n      <div ref=${containerRef} style=${{ width: '100%', height: '100%' }}></div>\n      \n      <div style=${{\n        position: 'absolute',\n        bottom: '20px',\n        right: '20px',\n        color: THEME.electricCyan,\n        fontFamily: 'JetBrains Mono',\n        fontSize: '12px',\n        pointerEvents: 'none',\n        textShadow: '0 0 8px #00f0ff'\n      }}>\n        AZURE REEF ENGINE v1.0 // BINS: 40\n      </div>\n    </div>\n  `;\n}",
  "outputs": {},
  "inputs_signature": {
    "data": "<input>"
  },
  "theme": {
    "name": "scuba_caribbean",
    "description": "This theme, titled **\"Azure Reef,\"** captures the vibrant, high-contrast clarity of a tropical dive, blending deep oceanic foundations with the luminous, neon-adjacent colors of a sunlit coral shelf.\n\nThe environment is a sophisticated dark mode that mimics the depths of the Caribbean Sea. The primary ground is a **deep, desaturated midnight teal**, providing a rich, cool-toned backdrop that ensures maximum contrast for data. Secondary surfaces\u2014such as cards and widget containers\u2014are styled in a **slightly more translucent \"Deep Water\" navy**, separated from the ground by a crisp, 1-pixel border in a faint sea-foam green. The overall feeling is technical yet refreshing, avoiding the \"flatness\" of pure black in favor of a layered, immersive aquatic atmosphere.\n\nTypography is anchored by **Montserrat** for body text and headers, providing a clean, geometric, and highly legible humanist feel that suggests modern exploration. For data values and code, **JetBrains Mono** is used to provide a sharp, technical texture. Text is rendered in a **bright \"Sea Salt\" white** (WCAG AA compliant) for primary labels, while secondary metadata uses a **muted \"Sand\" grey** to maintain a clear visual hierarchy.\n\nThe color system is driven by a **saturated Electric Cyan** accent, which acts as the primary interactive signal, glowing against the dark background. Semantic states are integrated with high-visibility tropical hues: **Emerald Green** for success, **Vivid Amber** for warnings, and **Hibiscus Red** for errors. The **Categorical Palette** is a 10-color \"Coral Reef\" sequence featuring high-contrast, colorblind-safe shades of Turquoise, Flamingo Pink, Sun-Bleached Yellow, and Bright Violet. The **Sequential Palette** transitions from a **dim, translucent kelp-green** to a **blindingly bright neon aqua**, representing depth or intensity through both luminosity and saturation. The **Diverging Palette** uses a **warm Sunset Orange** on one end and a **cool Deep Cobalt** on the other, meeting at a **neutral, desaturated slate** midpoint.\n\nChart elements are designed to be unobtrusive but structural. Axes are rendered in a **thin, 0.5px stroke of \"Mist\" grey**, while gridlines are nearly invisible, appearing only as **subtle, widely spaced dotted lines** that suggest the refraction of light through water. The chart frame itself is open and airy, allowing data marks to float freely without being boxed in.\n\nInteractions feel **buoyant and fluid**. On hover, data marks should undergo a **subtle \"glow\" effect** (an outer shadow of the mark's color) and a slight scale increase of 5%. Focus rings for keyboard navigation are a **thick, high-contrast \"Sunlight\" Yellow** to ensure no ambiguity. Tooltips are styled as **floating glassmorphic cards** with a blurred background and a sharp, white border, making them pop as if they are bubbles rising to the surface. Default mark opacity is set to **85%**, allowing overlapping data points to build up in saturation, mimicking the way light intensifies in shallow, crowded waters."
  },
  "components": [],
  "model": "google/gemini-3-flash-preview",
  "audit": null,
  "save_inputs": {
    "embedded": false,
    "values": {}
  }
}